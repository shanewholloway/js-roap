import {ao_pipe, ao_iter, ao_run} from 'roap'

import @{}
  assert, expect,
  delay_race, delay, delay_walk,
  array_from_ao_iter,
  is_fn, is_gen, is_async_iterable
from './_utils.jsy'


describe @ 'core ao_pipe', function() ::
  it @ 'shape', @::
    let pipe = is_async_iterable @ ao_pipe()
    is_gen @ pipe.g_in


  describe @ 'compute', @::
    it @ 'xfold', @::>
      let pipe = ao_pipe @:
        xsrc: delay_walk @# 30,20,10
        xfold: v => 1000 + v

      let z = array_from_ao_iter(pipe)
      assert.deepEqual @ await z, @[] 1030, 1020, 1010


    it @ '*xgfold', @::>
      let pipe = ao_pipe @:
        xsrc: delay_walk @# 30,20,10
        *xgfold() ::
          let s = 0
          while 1 ::
            let v = yield s
            s += v + 1000

      let z = array_from_ao_iter(pipe)
      assert.deepEqual @ await z, @[] 1030, 2050, 3060


    it @ 'xsrc', @::>
      let pipe = ao_pipe @:
        xsrc: delay_walk @# 30,20,10

      let z = array_from_ao_iter(pipe)
      assert.deepEqual @ await z, @[] 30,20,10


    it @ 'xctx', @::>
      let log=[]

      let pipe = ao_pipe @:
        *xctx(g_in) ::
          log.push @ 'xctx start'
          let tid = setTimeout @ 
            v => g_in.next(v)
            1, 'bingo'

          try :: yield
          finally ::
            clearTimeout(tid)
            log.push @ 'xctx fin'

      let z = array_from_ao_iter(pipe)

      assert.deepEqual @ log, @[] 'xctx start'

      await delay(5)
      pipe.stop()

      assert.deepEqual @ log, @[] 'xctx start', 'xctx fin'

      assert.deepEqual @ await z, @[] 'bingo'


  describe @ 'g_in: source generator feed', @::
    it @ 'with', @::>
      let log=[]

      let pipe = ao_pipe()

      pipe.g_in.with_ctx @\ g_in ::*
        log.push @ 'g_in.with start'
        let tid = setTimeout @ 
          v => g_in.next(v)
          1, 'bingo'

        try :: yield
        finally ::
          clearTimeout(tid)
          log.push @ 'g_in.with fin'

      let z = array_from_ao_iter(pipe)

      assert.deepEqual @ log, @[] 'g_in.with start'

      await delay(5)
      pipe.stop()

      assert.deepEqual @ log, @[] 'g_in.with start', 'g_in.with fin'

      assert.deepEqual @ await z, @[] 'bingo'


    it @ 'feed', @::>
      let pipe = ao_pipe()
      let z = array_from_ao_iter(pipe)

      await pipe.g_in.feed @
        delay_walk @# 1942, 2042, 2142

      pipe.stop()
      assert.deepEqual @ await z, @[] 1942, 2042, 2142


    it @ 'bind_vec', @::>
      let pipe = ao_pipe()
      let z = ao_iter(pipe).next()
      let send = pipe.g_in.bind_vec @ 'a', 'b', 'c'
      send('bind_vec')

      z = await z
      assert.deepEqual @ z.value,
        @[] 'a', 'b', 'c', 'bind_vec'


    it @ 'bind_obj', @::>
      let pipe = ao_pipe()
      let z = ao_iter(pipe).next()
      let send = pipe.g_in.bind_obj @ 'zed', @{}
        a: 'aaa', b: 'bbb'

      send('bind_obj')
      z = await z
      assert.deepEqual @ z.value,
        @{} a:'aaa', b:'bbb', zed: 'bind_obj'


  describe @ 'output async generator', @::
    it @ 'raw', @::>
      let gs = is_gen @
        ao_pipe @:
          xsrc: delay_walk @# 30,20,10
          kind: 'raw'

      let v0 = gs.next()
      expect(v0).to.be.a('promise')

      let p = ao_run(gs)
      expect(p).to.be.a('promise')
      expect(await p).to.be.undefined

      let v1 = gs.next()
      expect(v1).to.be.a('promise')

      expect(await v0).to.deep.equal @: value: 30, done: false
      expect(await v1).to.deep.equal @: value: undefined, done: true


    it @ 'tap', @::>
      let gs = is_async_iterable @
        ao_pipe @:
          xsrc: delay_walk @# 30, 20, 10
          kind: 'tap'

      let a = array_from_ao_iter(gs.ao_fork())
      let b = array_from_ao_iter(gs.ao_fork())

      let z = array_from_ao_iter(gs)
      expect(gs.fence).to.be.a('function')

      expect(a).to.be.a('promise')
      expect(b).to.be.a('promise')
      expect(z).to.be.a('promise')

      let p = gs.fence()
      expect(p).to.be.a('promise')
      expect(await p).to.equal @ 30

      expect(await z).to.deep.equal @# 30, 20, 10
      expect(await a).to.deep.equal @# 30, 20, 10
      expect(await b).to.deep.equal @# 30, 20, 10


    it @ 'split', @::>
      let gs = is_async_iterable @
        ao_pipe @:
          xsrc: delay_walk @# 30, 20, 10
          kind: 'split'

      let a = array_from_ao_iter(gs)
      let b = array_from_ao_iter(gs.ao_fork())
      let z = array_from_ao_iter(gs)

      expect(gs.fence).to.be.a('function')
      expect(gs.fin).to.be.a('promise')

      expect(a).to.be.a('promise')
      expect(b).to.be.a('promise')
      expect(z).to.be.a('promise')

      let p = gs.fence()
      expect(p).to.be.a('promise')
      expect(await p).to.equal @ 30

      expect(await z).to.deep.equal @# 30, 20, 10
      expect(await a).to.deep.equal @# 30, 20, 10
      expect(await b).to.deep.equal @# 30, 20, 10

