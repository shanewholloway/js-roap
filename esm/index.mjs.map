{"version":3,"file":"index.mjs","sources":["../code/core_iters.jsy","../code/_common.jsy","../code/core_fence.jsy","../code/core_latest.jsy","../code/basic.jsy","../code/track_deps.jsy","../code/track_updates.jsy","../code/track_dyn.jsy","../code/dom_std_utils.jsy","../code/dom_std.jsy","../code/dom_core.jsy","../code/dom.jsy","../code/time.jsy"],"sourcesContent":["export const sym_ao = Symbol.asyncIterator\nexport const sym_iter = Symbol.iterator\n\nexport async function * as_ao_iter(ao_iterable) ::\n  yield * ao_iterable\n\nexport function is_ao_iter(v) ::\n  return v !== undefined && v !== null\n    && 'function' === typeof v[sym_ao]\n\nexport function is_ao_iterable(v) ::\n  return v !== undefined && v !== null\n    && 'string' !== typeof v\n    && 'function' === typeof (v[sym_ao] || v.next || v[sym_iter])\n\nexport function as_ao_iter_checked(ao_iterable) ::\n  if ! is_ao_iterable(ao_iterable) ::\n    throw new TypeError @ 'Expected an ao_iterable'\n\n  return as_ao_iter(ao_iterable)\n\n","export const _ret_void = e => {}\nexport const _fn_true = ()=> true\nexport const _fn_false = ()=> false\nexport const _ident = e => e\nexport const _is_defined = e => undefined !== e\nexport const _e_value = e => e.value\nexport const _e_tip = e => e.tip\n\nexport function as_fn(fn, absent) ::\n  if ! fn || true === fn ::\n    return absent\n  if 'function' !== typeof fn ::\n    throw new TypeError()\n  return fn\n\nexport const deferred = @!\n  const _l=[], _lset = _l.splice.bind(_l, 1, 3)\n  return host => @\n    _l[0] = new Promise(_lset)\n    _l\n\n","import {_ret_void} from './_common.jsy'\n\nexport function ao_fence() ::\n  let _fp, _resume = _ret_void\n  const _set = y => _resume = y\n  return [fence, resume]\n\n  function fence() ::\n    if undefined === _fp ::\n      _fp = new Promise @ _set\n\n    return _fp\n\n  function resume(v) ::\n    _fp = undefined\n    _resume(v)\n\n","import {_ident, deferred} from './_common.jsy'\nimport {sym_ao} from './core_iters.jsy'\nimport {ao_fence} from './core_fence.jsy'\n\nexport const sym_ao_latest = Symbol('ao_latest')\n\n\nexport async function * _ao_iter_latest(aod) ::\n  let _cur\n  while true ::\n    let _tip\n    while _cur === (_tip = aod.tip) ::\n      if aod.done :: return\n\n      await aod.tail()\n\n    yield _cur = _tip\n\n\nconst __ao_latest__ = @{}\n  xform: _ident\n\n  get [sym_ao_latest]() ::\n    return this\n  get [sym_ao]() ::\n    return _ao_iter_latest.bind(null, this)\n  ao_iter() ::\n    return _ao_iter_latest(this)\n\n  async ao_each(fn) ::\n    for await const tip of this ::\n      await fn(tip)\n\n  async * ao_map(fn) ::\n    for await const tip of this ::\n      yield await fn(tip)\n\n  async * ao_filter(fn) ::\n    for await const tip of this ::\n      if await fn(tip) ::\n        yield tip\n\n  async * ao_map_if(fn) ::\n    for await const tip of this ::\n      const res = await fn(tip)\n      if res :: yield res\n\n\nexport function ao_latest() ::\n  const [tail, resume] = ao_fence()\n  const [_fin, _do_stop] = deferred()\n\n  const aod = @{}\n    __proto__: __ao_latest__\n    tip: undefined, done: false,\n    stop, tail\n\n  Object.assign @ update, @{}\n    update, stop, \n    fin: fn => _fin.finally @ _as_fin(fn)\n\n  return @[] aod, update\n\n  function update(tip) ::\n    aod.tip = tip = aod.xform @ tip\n    resume @ tip\n\n  function stop(v) ::\n    aod.done = true\n    resume()\n    _do_stop(v)\n    return _fin\n\n\nfunction _as_fin(fn) ::\n  if 'function' === typeof fn.return ::\n    return v => fn.return(v)\n  return fn\n\n","export * from './core.jsy'\nimport {sym_ao, sym_ao_latest, as_ao_iter_checked, ao_latest} from './core.jsy'\n\n\nexport function ao_push(xform) ::\n  const [aod, ao_push] = ao_latest()\n  if undefined !== xform ::\n    aod.xform = as_fn(xform)\n\n  ao_push.aod = aod\n  ao_push[sym_ao_latest] = aod\n  ao_push[sym_ao] = aod[sym_ao]\n  return ao_push\n\n\n\nexport function ao_watch(ao_iter) ::\n  ao_iter = as_ao_iter_checked(ao_iter)\n\n  const [aod, ao_update] = ao_latest()\n  ao_update.fin @ ao_iter\n  aod.complete = _ao_walk @ aod, ao_iter, ao_update\n  return aod\n\nexport async function _ao_walk(ctrl, ao_iter, fn) ::\n  for await const v of ao_iter ::\n    await fn(v)\n    if ctrl.done :: return\n\n\n\nexport function ao_update_ctx(ao_ctx_mgr) ::\n  const [aod, ao_update] = ao_latest()\n\n  ao_ctx_mgr = as_ao_iter_checked @\n    ao_ctx_mgr(ao_update)\n\n  ao_update.fin @ ao_ctx_mgr\n  aod.ready = _ao_init @ ao_ctx_mgr, aod\n  return aod\n\nasync function _ao_init(ao_ctx_mgr, aod) ::\n  const {value: xform} = await ao_ctx_mgr.next()\n  if 'function' === typeof xform ::\n    aod.xform = xform\n  return true\n\n","import {_e_tip, _fn_true} from './_common.jsy'\nimport {sym_ao, sym_ao_latest, ao_watch} from './basic.jsy'\n\n\nexport async function as_ao_dep(arg) ::\n  if undefined !== arg && null !== arg || 'object' !== typeof arg ::\n\n    const aod = arg[sym_ao_latest]\n    if undefined !== aod ::\n      return aod\n\n    if arg[sym_ao] ::\n      return ao_watch(arg)\n\n    if 'object' === typeof arg && 'tip' in arg ::\n      return arg\n\n  return { tip: arg }\n\nexport async function ao_deps_map(by_entries) ::\n  const aow_deps = new Map()\n  for const [name, arg] of by_entries ::\n    aow_deps.set @ name, await as_ao_dep @ arg\n  return aow_deps\n\n\nexport async function ao_deps_vec(by_vec) ::\n  const aow_deps = []\n  for const arg of by_vec ::\n    aow_deps.push @ await as_ao_dep @ arg\n  return aow_deps\n\n\nexport async function _ao_deps_change(iter_deps) ::\n  await new Promise @\\ resolve ::\n    for const {tail} of iter_deps ::\n      if undefined !== tail ::\n        tail().then(resolve)\n\n\nexport async function _ao_deps_map_updates(ao_update, ...args) ::\n  const deps = await ao_deps_map @ args.pop()\n  const fence = args.shift() || _fn_true\n  while true ::\n    if await fence() ::\n      const snap = {}\n      for const [k, arg] of deps.entries() ::\n        snap[k] = arg.tip\n\n      ao_update @ snap\n\n    await _ao_deps_change @ deps.values()\n\n\nexport async function _ao_deps_vec_updates(ao_update, ...args) ::\n  const deps = await ao_deps_vec @ args.pop()\n  const fence = args.shift() || _fn_true\n  while true ::\n    if await fence() ::\n      const snap = Array.from @ deps, _e_tip\n\n      ao_update @ snap\n\n    await _ao_deps_change @ deps\n\n","import {ao_latest} from './core_latest.jsy'\nimport {_ao_deps_map_updates, _ao_deps_vec_updates} from './track_deps.jsy'\n\nexport function ao_track(...args) ::\n  const [aod, ao_update] = ao_latest()\n  const deps = args.pop()\n  if Array.isArray(deps) ::\n    args.push @ deps\n    aod.complete = _ao_deps_vec_updates @ ao_update, ... args\n\n  else ::\n    args.push @ Object.entries(deps)\n    aod.complete = _ao_deps_map_updates @ ao_update, ... args\n\n  return aod\n\nexport function ao_track_vec(...args) ::\n  const [aod, ao_update] = ao_latest()\n  aod.complete = _ao_deps_vec_updates @ ao_update, ...args\n  return aod\n\nexport function ao_track_entries(...args) ::\n  const [aod, ao_update] = ao_latest()\n  aod.complete = _ao_deps_map_updates @ ao_update, ...args\n  return aod\n\nexport function ao_track_kw(...args) ::\n  args.push @ Object.entries @ args.pop()\n  const [aod, ao_update] = ao_latest()\n  aod.complete = _ao_deps_map_updates @ ao_update, ...args\n  return aod\n\n","import {ao_latest, is_ao_iter, _ao_walk} from './basic.jsy'\n\n\nexport function ao_dyn() ::\n  let _ctrl = {}\n\n  const [aod, ao_update] = ao_latest()\n  aod.get = @=> aod\n  aod.set = _dyn_set\n  return aod\n\n  function _dyn_set(dyn_val) ::\n    _ctrl.done = true\n\n    if is_ao_iter(dyn_val) ::\n      _ctrl = {done: false}\n      _ao_walk(_ctrl, dyn_val, ao_update)\n      return true\n\n    else ::\n      ao_update(dyn_val)\n      return true\n\n\nexport function ao_dyn_ns(ns = new Map()) ::\n  return @{}\n    has: k => ns.has(k)\n    get: k => ao_dyn_at(k).get()\n    set: (k, v) => ao_dyn_at(k).set(v)\n\n  function ao_dyn_at(k) ::\n    let ao = ns.get(k)\n    if undefined === ao ::\n      ao = ao_dyn()\n      ns.set(k, ao)\n    return ao\n\n\nexport function ao_dyn_obj(ns = new Map()) ::\n  return _ns_obj_proxy @ ao_dyn_ns(ns)\n\nexport function _ns_obj_proxy(ns = new Map()) ::\n  return new Proxy @ {}, @{}\n    has: (ot, k) => ns.has(k)\n    get: (ot, k) => ns.get(k)\n    set: (ot, k, v) => ns.set(k, v)\n\n","\nexport function _dom_unpack_args(std, elem, dom_args) ::\n  if 'string' === typeof elem ::\n    elem = document.querySelector(elem)\n\n  return ! dom_args || 0 === dom_args.length\n    ? _dom_builtin(std, elem)\n    : _as_dom_arg(elem, dom_args)\n\n\nexport function _dom_builtin(std, elem) ::\n  let {tagName: tag, type} = elem\n  tag = `tag:${tag.toLowerCase()}`\n\n  const dom_args = type && std[`${tag} type:${type.toLowerCase()}`]\n      || std[tag]\n      || std._\n\n  return 'function' === typeof dom_args\n    ? dom_args.call(std, elem, std)\n    : _as_dom_arg(elem, dom_args)\n\n\nfunction _as_dom_arg(elem, dom_args) ::\n  return Array.isArray(dom_args)\n    ? @{} elem, evt_names: dom_args[0], on_evt: dom_args[1]\n    : @{} elem, ... dom_args\n\n","import {_e_value} from './_common.jsy'\nimport {_dom_unpack_args} from './dom_std_utils.jsy'\nexport * from './dom_std_utils.jsy'\n\n\n\nconst _en_click = ['click']\nconst _en_input = ['input', 'change']\nconst _evt_message = @[] 'message', (_, evt) => evt.data\nconst _e_no_default = e => e.preventDefault()\nconst _opt_unpack = ({text, value}) => @: text, value\n\n\nexport const _dom_std_args = @{}\n  _: @[] _en_click\n  'tag:input': @[] _en_input, _e_value\n  'tag:output': @[] _en_input, _e_value\n  'tag:input type:number': @[] _en_input, e => e.valueAsNumber\n  'tag:input type:range': @[] _en_input, e => e.valueAsNumber\n  'tag:input type:button': @[] _en_click, _e_value\n  'tag:input type:submit': @[] _en_click, _e_value\n  'tag:input type:checkbox': @[] _en_input, e => e.checked\n  'tag:input type:radio': @[] _en_input, e => e.checked\n  'tag:input type:date': @[] _en_input, e => e.valueAsDate\n  'tag:input type:time': @[] _en_input, e => e.valueAsNumber\n  'tag:input type:file': @[] _en_input, e => e.multiple ? e.files : e.files[0]\n  'tag:textarea': @[] _en_input, _e_value\n  'tag:select': @{}\n      evt_names: _en_input\n      on_evt(e) ::\n        const res = Array.from @ e.selectedOptions, _opt_unpack\n        return e.multiple ? res : res[0]\n\n  'tag:form': @{}\n      evt_names: _en_input\n      on_evt: e => new FormData(e)\n      on_add(e) :: e.addEventListener @ 'submit', _e_no_default\n\n\nexport const _dom_std_unpack_args = \n  _dom_unpack_args.bind @ null, _dom_std_args\n\n","import {ao_update_ctx} from './basic.jsy'\nimport {_ident, as_fn} from './_common.jsy'\n\nexport function ao_dom_updates({elem, evt_names, on_evt, on_calc, on_add, on_remove}) ::\n  if ! Array.isArray(evt_names) ::\n    evt_names = (evt_names || 'click').split(/\\s+/)\n\n  const extra = on_evt || {}\n  if 'function' !== typeof on_evt ::\n    on_evt = as_fn(extra.on_evt, _ident)\n\n  return ao_update_ctx @\\ ao_update ::*\n    function _update(evt) ::\n      evt = on_evt(elem, evt, ao_update)\n      if undefined !== evt ::\n        ao_update(evt)\n\n    if extra.on_add ::\n      extra.on_add(elem)\n\n    for const e of evt_names ::\n      elem.addEventListener @ e, _update\n\n    try ::\n      _update({})\n      yield extra.on_calc\n\n    finally ::\n      for const e of evt_names ::\n        elem.removeEventListener @ e, _update\n\n      if extra.on_remove ::\n        extra.on_remove(elem)\n\n","import {_ident} from './_common.jsy'\nimport {ao_update_ctx} from './basic.jsy'\nimport {_dom_std_unpack_args} from './dom_std.jsy'\nimport {ao_dom_updates} from './dom_core.jsy'\n\nexport * from './dom_core.jsy'\nexport * from './dom_std.jsy'\n\n\nexport function ao_dom(elem, ...args) ::\n  return ao_dom_updates @\n    _dom_std_unpack_args(elem, args)\n\n\nexport function ao_animation_frames() ::\n  return ao_update_ctx @\\ ao_update ::*\n    function _update(ts) ::\n      ao_update(ts)\n      rid = requestAnimationFrame @ _update\n\n    let rid = requestAnimationFrame @ _update\n    try :: yield\n    finally :: cancelAnimationFrame(rid)\n\n\nexport function ao_dom_storage() ::\n  return ao_update_ctx @\\ ao_update ::*\n    function _on_stg({storageArea:sa, key:k, newValue:v, url}) ::\n      if undefined === sa :: return\n      const entry = @[] k, v\n      entry.url = url\n      ao_update(entry)\n\n    window.addEventListener @ 'storage', _on_stg\n    try :: yield\n    finally ::\n      window.removeEventListener @ 'storage', _on_stg\n\n\nexport function ao_dom_messages(msg_host, xform=_ident) ::\n  return ao_update_ctx @\\ ao_update ::*\n    msg_host.onmessage = data => ao_update(data)\n\n    yield xform\n\n","import {ao_update_ctx} from './basic.jsy'\n\nexport const delay = (...args) =>\n  new Promise @ y =>\n    setTimeout @ y, ...args\n\nexport function ao_pulse(ms, immediate) ::\n  return ao_update_ctx @\\ ao_update ::*\n    const ts0 = Date.now()\n    function _pulse() ::\n      ao_update @ Date.now() - ts0\n\n    const tid = setInterval @ _pulse, ms\n    try ::\n      if immediate :: _pulse()\n\n      yield\n\n    finally ::\n      clearInterval @ tid\n\n"],"names":[],"mappings":"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"}