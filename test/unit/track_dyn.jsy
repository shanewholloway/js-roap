import @{}
  as_ao_iter,
  ao_dyn, ao_dyn_ns, ao_dyn_obj, 
from 'roap'

import @{}
  assert, expect, delay, delay_race
  expect_ao_latest, expect_ao_api
from './_utils.jsy'


describe @ 'track dynamic', @::
  it @ 'smoke', @::
    expect(ao_dyn).to.be.a('function')
    expect(ao_dyn_ns).to.be.a('function')
    expect(ao_dyn_obj).to.be.a('function')

  it @ 'ao_dyn shape', @::>
    const aod = ao_dyn()

    expect(aod.get).to.be.a('function')
    expect(aod.set).to.be.a('function')

    expect(aod.get()).to.be.equal(aod)

    expect_ao_latest(aod)


  it @ 'ao_dyn exercise', @::>
    await validate_ao_dyn @ ao_dyn()


  it @ 'ao_dyn_ns exercise', @::>
    const map = new Map()
    const ns = ao_dyn_ns(null, map)

    expect(map.size).to.equal(0)

    await Promise.all @#
      validate_ao_dyn @ ns.get('one')
      validate_ao_dyn @ ns.get('two')

    expect(map.size).to.equal(2)
    ns.set('three', 'some specific value')

    expect(map.size).to.equal(3)
    expect(ns.has('one')).is.true
    expect(ns.has('does not exist')).is.false

    for await const v of ns.get('two') ::
      expect(v).to.equal('works')
      break

    for await const v of ns.get('three') ::
      expect(v).to.equal('some specific value')
      break

    ::
      expect(ns.has('fourth')).is.false

      ns.set('fourth', 'bingo')
      expect @ ns.get('fourth').tip
      .to.be.equal @ 'bingo'

      expect(map.size).to.equal(4)
      expect(ns.has('fourth')).is.true
      expect(ns.has('does not exist')).is.false

      for await const v of ns.get('fourth') ::
        expect(v).to.equal('bingo')
        break


  it @ 'ao_dyn_obj exercise', @::>
    const map = new Map()
    const ns_obj = ao_dyn_obj(null, map)

    expect(map.size).to.equal(0)

    await Promise.all @#
      validate_ao_dyn @ ns_obj.one
      validate_ao_dyn @ ns_obj.two

    expect(map.size).to.equal(2)
    ns_obj.three = 'some specific value'

    expect(map.size).to.equal(3)
    expect(map.has('one')).is.true
    expect(map.has('does not exist')).is.false

    for await const v of ns_obj.one ::
      expect(v).to.equal('works')
      break

    expect @ ns_obj.one.tip
    .to.equal('works')

    for await const v of ns_obj.three ::
      expect(v).to.equal('some specific value')
      break



async function validate_ao_dyn(dyn) ::
  const ao = as_ao_iter(dyn)

  ::
    const p_0 = ao.next()
    expect @ await delay_race @ p_0
    .to.be.equal @ 'timeout'

    dyn.set(1942)

    expect @ await p_0
    .to.be.deep.equal @: value: 1942, done: false



  async function * _test_vec() ::
    yield 10
    yield 20
    yield 30


  ::
    const p_1 = ao.next()
    expect @ await delay_race @ p_1
    .to.be.equal @ 'timeout'


    dyn.set(_test_vec())

    expect @ await p_1
    .to.be.deep.equal @: value: 10, done: false


  expect @ await ao.next()
  .to.be.deep.equal @: value: 20, done: false

  expect @ await ao.next()
  .to.be.deep.equal @: value: 30, done: false


  ::
    const p_2 = ao.next()
    expect @ await delay_race @ p_2
    .to.be.equal @ 'timeout'


    dyn.set('works')

    expect @ await p_2
    .to.be.deep.equal @: value: 'works', done: false

