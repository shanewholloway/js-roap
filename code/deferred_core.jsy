import { sym_ao } from './core.jsy'


export const deferred = @!
  const l=[], lset = l.splice.bind(l, 0, 2)
  return function deferred(host) ::
    'use strict';
    if undefined === host ::
      host = this || {reset: deferred}

    host.promise = new Promise(lset)
    host.resolve = l[0]
    host.reject = l[1]
    return host


const __ao_deferred__ = @{}
  tip: undefined
  valid: false
  done: false
  reset: deferred

  get [sym_ao]() ::
    return ao_iter_deferred.bind(null, this)


export async function * ao_iter_deferred(aod, only_next) ::
  if !only_next && aod.valid ::
    yield aod.tip

  while true ::
    await aod.promise
    if false !== aod.done ::
      return await aod.done
    yield aod.tip


export function ao_deferred(init_ao) ::
  const aod = deferred @:
    __proto__: __ao_deferred__

  if undefined !== init_ao ::
    aod.init = init_ao(ao_update)
  else aod.ao_update = ao_update

  return aod

  function ao_update(v) ::
    aod.valid = true
    aod.tip = v
    aod.resolve(v)
    return aod.promise


export function ao_deferred_gen(init_ao) ::
  const aod = deferred @:
    __proto__: __ao_deferred__

  const ao_gen = @{}
    update(v) ::
      aod.valid = true
      aod.tip = v
      aod.resolve(v)
      return aod.promise

    return(v) ::
      aod.done = Promise.resolve(v)
      aod.resolve()
      return aod.done

    throw(err) ::
      aod.done = Promise.reject(err)
      aod.resolve()
      return aod.done

  if undefined !== init_ao ::
    aod.init = init_ao(ao_gen)
  else aod.ao_gen = ao_gen

  return aod

