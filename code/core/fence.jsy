import {ao_when_map} from './when.jsy'
import {ao_defer_ctx} from './defer.jsy'
import {ao_done, ao_check_done} from './util.jsy'


export function ao_fence_v(proto) ::
  let x, p0, p=0, reset=ao_defer_ctx()

  let fence  = at => @ 0===at ? p0 : 0!==p ? p : p=(x=reset())[0]
  let resume = ans => xz(x[1], ans)
  let abort  = err => xz(x[2], err || ao_done)

  p0 = fence() // initialize x, p, and p0
  return proto
    ? @{} __proto__: proto, fence, resume, abort
    : @[] fence, resume, abort

  function xz(xf, v) ::
    if 0!==p ::
      p0 = p; p = 0
      xf(v)

export const ao_fence_when = db =>
  ao_when_map(ao_fence_v, db)

export async function * ao_iter_fence(fence) ::
  try ::
    while 1 ::
      let r = await fence()
      if undefined !== r ::
        yield r
  catch err ::
    ao_check_done(err)



export const _ao_fence_core_api_ = /* #__PURE__ */ @{}
  ao_check_done

  // copyable fence fork api
  [Symbol.asyncIterator]() ::
    return this.ao_fork()

  ao_fork() ::
    let ag = ao_iter_fence(this.fence)
    let {xemit} = this
    return xemit ? xemit(ag) : ag


export function ao_fence_fn(tgt) ::
  let f = ao_fence_v()
  if undefined === tgt :: tgt = f[0]
  tgt.fence = Object.assign(tgt, _ao_fence_core_api_)
  return f


export const ao_fence_obj = /* #__PURE__ */
  ao_fence_v.bind(null, _ao_fence_core_api_)


export function as_iter_proto(resume, abort, done = true) ::
  return @{}
    next: v => @: value: resume(v), done
    return: () => @: value: abort(ao_done), done
    throw: (err) => @: value: abort(err), done

