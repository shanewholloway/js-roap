import {as_ao_iter, is_ao_iterable, sym_ao, ao_tail_obj} from './core.jsy'

export @{}
  ao_watch as default

const __ao_watch__ = @{}
  get [sym_ao]() :: return ao_tail_obj(this)

export async function ao_watch(...args) ::
  let ao_obj={__proto__: __ao_watch__}, ao_iter, on_update
  for const ea of args ::
    if 'function' === typeof ea ::
      on_update = ea
    else if is_ao_iterable(ea) ::
      ao_iter = as_ao_iter(ea)
    else ao_obj = ea

  return _ao_walker @ ao_obj, ao_iter, on_update

export async function _ao_walker(ao_obj, ao_iter, on_update) ::
  const {value, done} = await ao_iter.next()
  ao_obj.value = value
  ao_obj.done = done
  ao_obj.tail = undefined

  if undefined !== on_update ::
    const res = await on_update @ value, ao_obj
    if undefined !== res ::
      ao_obj.value = res

  // don't start the walker until after on_update has been sent
  ao_obj.tail = done ? Promise.resolve(ao_obj)
    : _ao_walker @ ao_obj, ao_iter, on_update
  return ao_obj

export async function as_ao_watch(arg) ::
  arg = await arg
  if undefined !== arg && null !== arg ::
    if undefined !== arg.tail ::
      return arg // already an ao_watch instance

    if is_ao_iterable(arg) ::
      return await _ao_walker @
        {__proto__: __ao_watch__}
        as_ao_iter(arg)

  return @{} value: arg, done: true

