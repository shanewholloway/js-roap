import {_ident, deferred} from './_common.jsy'
import {sym_ao} from './core_iters.jsy'
import {ao_fence} from './core_fence.jsy'

export const sym_ao_latest = Symbol('ao_latest')


export function ao_push(xform) ::
  const [aod, ao_push] = ao_latest()
  if undefined !== xform ::
    aod.xform = as_fn(xform)

  ao_push.aod = aod
  ao_push[sym_ao_latest] = aod
  ao_push[sym_ao] = aod[sym_ao]
  return ao_push


export async function * _ao_iter_latest(aod) ::
  let _cur
  while true ::
    let _tip
    while _cur === (_tip = aod.tip) ::
      if aod.done :: return

      await aod.tail()

    yield _cur = _tip


const __ao_latest__ = @{}
  xform: _ident

  get [sym_ao_latest]() ::
    return this
  get [sym_ao]() ::
    return _ao_iter_latest.bind(null, this)
  ao_iter() ::
    return _ao_iter_latest(this)

  async ao_each(fn) ::
    for await const tip of this ::
      await fn(tip)

  async * ao_map(fn) ::
    for await const tip of this ::
      yield await fn(tip)

  async * ao_filter(fn) ::
    for await const tip of this ::
      if await fn(tip) ::
        yield tip

  async * ao_map_if(fn) ::
    for await const tip of this ::
      const res = await fn(tip)
      if res :: yield res


export function ao_latest() ::
  const [tail, resume] = ao_fence()
  const [_fin, _do_stop] = deferred()

  const aod = @{}
    __proto__: __ao_latest__
    tip: undefined, done: false,
    stop, tail

  Object.assign @ update, @{}
    update, stop, 
    fin: fn => _fin.finally @ _as_fin(fn)

  return @[] aod, update

  function update(tip) ::
    aod.tip = tip = aod.xform @ tip
    resume @ tip

  function stop(v) ::
    aod.done = true
    resume()
    _do_stop(v)
    return _fin


function _as_fin(fn) ::
  if 'function' === typeof fn.return ::
    return v => fn.return(v)
  return fn

