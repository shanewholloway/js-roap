import {ao_fence_fn} from './core/fence.jsy'
import {ao_check_done} from './core/util.jsy'

export function ao_interval(ms=1000) ::
  let [_fence, _resume, _abort] = ao_fence_fn()
  let tid = setInterval(_resume, ms, 1)
  if tid.unref :: tid.unref()
  _fence.stop = @::
    tid = clearInterval(tid)
    _abort()
  return _fence


export function ao_timeout(ms=1000) ::
  let tid, [_fence, _resume] = ao_fence_fn(timeout)
  return timeout

  function timeout() ::
    tid = setTimeout(_resume, ms, 1)
    if tid.unref :: tid.unref()
    return _fence()


export function ao_debounce(ms=300, gen_in) ::
  let tid, [_fence, _resume] = ao_fence_fn()

  _fence.fin = @!>
    try ::
      let p
      for await let v of gen_in ::
        clearTimeout(tid)
        p = _fence()
        tid = setTimeout(_resume, ms, v)

      await p
    catch err ::
      ao_check_done(err)

  return _fence


export function ao_ratelimit(ms=300, gen_in) ::
  let tid=null, [_fence, _resume] = ao_fence_fn()
  let _reset = () => tid = null

  _fence.fin = @!>
    try ::
      for await let v of gen_in ::
        if null === tid ::
          _resume(v)
          tid = setTimeout(_reset, ms)
    catch err ::
      ao_check_done(err)

  return _fence


export async function * ao_times(gen_in) ::
  let ts0 = Date.now()
  for await let v of gen_in ::
    yield Date.now() - ts0

