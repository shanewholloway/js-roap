import { _is_fn, _obj_assign } from './_common.jsy'
import { _ao_pipe_base } from './pipe_base.jsy'
import { _ao_pipe_in } from './pipe_in.jsy'
import { _ao_pipe_out } from './pipe_out.jsy'


export const _ao_pipe = @{}
  __proto__: _ao_pipe_base

  // xfold: v => v -- on push: identity transform
  // xpull() {} -- memory: none
  // xemit: _xinvoke -- identity transform or invoke if function

  // *xgfold() -- on push: generator-based fold impl
  // *xsrc() -- feed with source generator
  // *xctx(gen_src) -- on init: bind event sources

  kind: 'split'
  _as_pipe_in: _ao_pipe_in
  _as_pipe_out: _ao_pipe_out

  xinit(g_in) ::
    let xgfold = this.xgfold
    if undefined !== xgfold ::
      this._init_xgfold(g_in, xgfold)

    this._init_chain(g_in)


  _init_xgfold(g_in, xgfold) ::
    if undefined === xgfold ::
      return

    if _is_fn(xgfold) ::
      xgfold = xgfold.call(this, this)

      if _is_fn(xgfold) ::
        this.xfold = xgfold
        return true

      xgfold.next()

    this.xgfold = xgfold
    this.xfold = this._fold_gen
    g_in.on_fin @ xgfold
    return true

  _fold_gen(v) ::
    let {done, value} = this.xgfold.next(v)
    if done :: this.done = true
    return value


  _init_chain(g_in) ::
    let {xsrc, xctx} = this
    if undefined !== xsrc ::
      g_in.feed(xsrc)
        .then @=> g_in.return()

    if undefined !== xctx ::
      g_in.with_ctx(xctx)


export const ao_pipe = _ao_pipe.create

