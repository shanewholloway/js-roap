import {ao_fence_in, ao_drive} from 'roap'

import @{}
  assert, expect,
  delay_race, delay, delay_walk
  array_from_ao_iter,
  is_fn, is_gen, is_async_iterable
from './_utils.jsy'


describe @ 'ao_fence_in.ao_pipe basics', function() ::
  it @ 'shape', @::
    let some_pipe = is_async_iterable @
      ao_fence_in().ao_pipe()

    is_gen @ some_pipe.g_in
    expect(some_pipe.fence).to.be.a('function')
    expect(some_pipe.when_run).to.be.a('promise')

  it @ 'example', @::>
    let some_pipe = ao_fence_in().ao_pipe()
    let z = _test_pipe_out @ some_pipe,
      [1942, 2042, 2142]

    assert.deepEqual @
      @[] 1942, 2042, 2142
      await delay_race(z, 50)

  it @ 'xfold', @::>
    let some_pipe = ao_fence_in().ao_pipe @:
      *xrecv(g) ::
        let s = 0
        for let v of g ::
          s += v
          yield s

    let z = _test_pipe_out @ some_pipe,
      [1942, 2042, 2142]

    assert.deepEqual @
      @[] 1942, 1942+2042, 1942+2042+2142
      await delay_race(z, 50)


  it @ 'xemit', @::>
    let some_pipe = ao_fence_in().ao_pipe @:
      async * xemit(g) ::
        for await let v of g ::
          yield ['xe', v]

    let z = _test_pipe_out @ some_pipe,
      [1942, 2042, 2142]

    assert.deepEqual @
      @[] ['xe', 1942]
          ['xe', 2042]
          ['xe', 2142]
      await delay_race(z, 50)


  async function _test_pipe_out(some_pipe, values) ::
    let z = array_from_ao_iter(some_pipe)

    await ao_drive @
      delay_walk(values)
      some_pipe.g_in, true

    return z

