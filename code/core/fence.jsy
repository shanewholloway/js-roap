import {ao_done, ao_check_done, fn_chain} from './util.jsy'


export function ao_fence_v(proto) ::
  let p=0, _resume = _=>0, _abort = _=>0
  let _pset = (y,n) => :: _resume=y; _abort=n

  let fence = () => @ 0 !== p ? p : p=new Promise(_pset)
  let resume = (ans) => @ p=0, _resume(ans)
  let abort = (err=ao_done) => @ p=0, _abort(err)

  return proto
    ? @{} __proto__: proto, fence, resume, abort
    : @[] fence, resume, abort



export const _ao_fence_api_ = @{}
  __proto__: @{}
    // generator api
    next(v) :: return {value: this.resume(v), done: true}
    return() :: return {value: this.abort(ao_done), done: true}
    throw(err) :: return {value: this.abort(err), done: true}

    ao_check_done
    chain(fn) :: return fn_chain(this)(fn)

  // copyable fence api

  [Symbol.asyncIterator]() ::
    return this.ao_fork()

  async * ao_fork() ::
    let {fence} = this
    try ::
      while 1 ::
        yield await fence()
    catch err ::
      ao_check_done(err)


export function ao_fence_fn(tgt) ::
  let f = ao_fence_v()
  if undefined === tgt :: tgt = f[0]
  tgt.fence = Object.assign(tgt, _ao_fence_api_)
  return f


export const ao_fence_obj = ao_fence_v.bind @ null, @{}
  __proto__: _ao_fence_api_

  async * ao_gated(f_gate) ::
    try ::
      while 1 ::
        let v = await f_gate.fence()
        yield v
        this.resume(v)
    catch err ::
      ao_check_done(err)
    finally ::
      f_gate.abort()
      this.abort()

