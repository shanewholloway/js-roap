import {ao_fence_v, ao_fence_fn, ao_fence_obj} from 'roap'
import @{}
  assert, expect,
  delay_race, delay,
from './_utils.jsy'


describe @ 'ao_fence', @::
  describe @ 'ao_fence_v tuple', @::
    it @ 'shape', @::
      const res = ao_fence_v()
      expect(res).to.be.an('array').of.length(2)
      expect(res[0]).to.be.a('function')
      expect(res[1]).to.be.a('function')


    it @ 'basic use', @::>
      const [fence, resume] = ao_fence_v()

      const p = fence()
      assert.equal @ 'timeout', await delay_race(p,1)

      resume(1942)
      assert.equal @ 1942, await delay_race(p,1)


    it @ 'only first after', @::>
      const [fence, resume] = ao_fence_v()
      let f

      resume @ 'one'
      f = fence()
      resume @ 'two'
      resume @ 'three'

      assert.equal @ 'two', await f

      resume @ 'four'
      resume @ 'five'
      f = fence()
      resume @ 'six'
      resume @ 'seven'

      assert.equal @ 'six', await f


    it @ 'never blocked on fence', @::>
      const [fence, resume] = ao_fence_v()

      resume @ 'one'
      resume @ 'two'
      resume @ 'three'


    it @ 'exercise fence', @::>
      const [fence, resume] = ao_fence_v()

      let v = 'a'
      expect(v).to.equal('a')

      const p = @!>
        v = 'b'

        :: const ans = await fence()
           expect(ans).to.equal('bb')

        v = 'c'
        :: const ans = await fence()
           expect(ans).to.equal('cc')
        v = 'd'
        return 1942

      assert.equal @ 'timeout', await delay_race(p,1)
      expect(v).to.equal('b')

      ::
        const p = resume(v+v)
        expect(p).to.be.undefined

      expect(v).to.equal('b')
      assert.equal @ 'timeout', await delay_race(p,1)
      expect(v).to.equal('c')

      ::
        const p = resume(v+v)
        expect(p).to.be.undefined

      expect(v).to.equal('c')
      assert.equal @ 1942, await delay_race(p,1)
      expect(v).to.equal('d')


  describe @ 'ao_fence_fn', @::
    it @ 'shape', @::
      const res = ao_fence_fn()

      expect(res).to.be.an('array').of.length(2)
      expect(res[0]).to.be.a('function')
      expect(res[1]).to.be.a('function')
      expect(res[0].ao_fork).to.be.a('function')
      expect(res[0][Symbol.asyncIterator]).to.be.a('function')


    it @ 'basic use', @::>
      const [fence, reset] = ao_fence_fn()

      const p = fence()
      assert.equal @ 'timeout', await delay_race(p,1)

      reset(1942)
      assert.equal @ 1942, await delay_race(p,1)


    it @ 'async iter use', @::>
      const [fence, reset] = ao_fence_fn()

      delay().then @=> reset('ready')

      for await let v of fence ::
        assert.equal @ 'ready', v
        break


    it @ 'async iter multi use', @::>
      const [fence, reset] = ao_fence_fn()

      let pa = @!>
        for await let v of fence ::
          return `pa ${v}`

      let pb = @!>
        for await let v of fence.ao_fork() ::
          return `pb ${v}`

      let pc = fence()

      assert.equal @ 'timeout', await delay_race(pa,1)
      assert.equal @ 'timeout', await delay_race(pb,1)
      assert.equal @ 'timeout', await delay_race(pc,1)

      reset('ready')
      assert.equal @ 'pa ready', await delay_race(pa,1)
      assert.equal @ 'pb ready', await delay_race(pb,1)
      assert.equal @ 'ready', await delay_race(pc,1)


  describe @ 'ao_fence_obj', @::
    it @ 'shape', @::
      const res = ao_fence_obj()
      expect(res).to.be.an('object')
      expect(res.fence).to.be.a('function')
      expect(res.reset).to.be.a('function')
      expect(res.ao_fork).to.be.a('function')
      expect(res[Symbol.asyncIterator]).to.be.a('function')


    it @ 'basic use', @::>
      const res = ao_fence_obj()

      const p = res.fence()
      assert.equal @ 'timeout', await delay_race(p,1)

      res.reset(1942)
      assert.equal @ 1942, await delay_race(p,1)


    it @ 'async iter use', @::>
      const res = ao_fence_obj()

      delay().then @=> res.reset('ready')

      for await let v of res ::
        assert.equal @ 'ready', v
        break


    it @ 'async iter multi use', @::>
      const res = ao_fence_obj()

      let pa = @!>
        for await let v of res ::
          return `pa ${v}`

      let pb = @!>
        for await let v of res.ao_fork() ::
          return `pb ${v}`

      let pc = res.fence()

      assert.equal @ 'timeout', await delay_race(pa,1)
      assert.equal @ 'timeout', await delay_race(pb,1)
      assert.equal @ 'timeout', await delay_race(pc,1)

      res.reset('ready')
      assert.equal @ 'pa ready', await delay_race(pa,1)
      assert.equal @ 'pb ready', await delay_race(pb,1)
      assert.equal @ 'ready', await delay_race(pc,1)

