import {ao_fence_fn} from './core/fence.jsy'
import {ao_iter_fenced} from './core/drive.jsy'
import {ao_check_done} from './core/util.jsy'

export function ao_interval(ms=1000, gen_in) ::
  let [_fence, _resume, _abort] = ao_fence_fn()
  let tid = setInterval(_resume, ms, 1)
  if tid.unref :: tid.unref()
  _fence.stop = @::
    tid = clearInterval(tid)
    _abort()

  return null == gen_in ? _fence
    : ao_iter_fenced(gen_in, _fence)


export function ao_timeout(ms=1000, gen_in) ::
  let tid, [_fence, _resume] = ao_fence_fn(timeout)

  return null == gen_in ? timeout
    : ao_iter_fenced(gen_in, timeout)

  function timeout() ::
    tid = setTimeout(_resume, ms, 1)
    if tid.unref :: tid.unref()
    return _fence()


export function ao_debounce(ms=300, gen_in) ::
  let tid, [_fence, _resume] = ao_fence_fn()

  _fence.fin = @!>
    try ::
      let p
      for await let v of gen_in ::
        clearTimeout(tid)
        p = _fence()
        tid = setTimeout(_resume, ms, v)

      await p
    catch err ::
      ao_check_done(err)

  return _fence


export async function * ao_times(gen_in) ::
  let ts0 = Date.now()
  for await let v of gen_in ::
    yield Date.now() - ts0

