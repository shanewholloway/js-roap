{"version":3,"file":"index.mjs","sources":["../code/core_iters.jsy","../code/_common.jsy","../code/core_fence.jsy","../code/core_latest.jsy","../code/core_updates.jsy","../code/core_watch.jsy","../code/track_deps.jsy","../code/track_updates.jsy","../code/dom.jsy","../code/time.jsy"],"sourcesContent":["export const sym_ao = Symbol.asyncIterator\nexport const sym_iter = Symbol.iterator\n\nexport async function * as_ao_iter(ao_iterable) ::\n  yield * ao_iterable\n\nexport function is_ao_iterable(v) ::\n  return v !== undefined && v !== null &&\n    'function' === typeof (v[sym_ao] || v.next || v[sym_iter])\n\nexport function as_ao_iter_checked(ao_iterable) ::\n  if ! is_ao_iterable(ao_iterable) ::\n    throw new TypeError @ 'Expected an ao_iterable'\n\n  return as_ao_iter(ao_iterable)\n\n","export const _ret_void = e => {}\nexport const _ident = e => e\nexport const _is_defined = e => undefined !== e\nexport const _e_value = e => e.value\nexport const _e_tip = e => e.tip\n\nexport function as_fn(fn, absent) ::\n  if ! fn || true === fn ::\n    return absent\n  if 'function' !== typeof fn ::\n    throw new TypeError()\n  return fn\n\nexport const deferred = @!\n  const _l=[], _lset = _l.splice.bind(_l, 1, 3)\n  return host => @\n    _l[0] = new Promise(_lset)\n    _l\n\n","import {_ret_void} from './_common.jsy'\n\nexport function ao_fence() ::\n  let _fp, _resume = _ret_void\n  const _set = y => _resume = y\n\n  const resume = v => ::\n    _fp = undefined\n    _resume(v)\n\n  const fence = @=>\n    undefined !== _fp ? _fp :\n      _fp = new Promise @ _set\n\n  return [fence, resume]\n\n","import {_ident, deferred} from './_common.jsy'\nimport {sym_ao} from './core_iters.jsy'\nimport {ao_fence} from './core_fence.jsy'\n\n\nexport function ao_push(xform) ::\n  const [aod, ao_push] = ao_latest()\n  if undefined !== xform ::\n    aod.xform = as_fn(xform)\n\n  ao_push.aod = aod\n  ao_push[sym_ao] = aod[sym_ao]\n  return ao_push\n\n\nexport async function * _ao_iter_latest(aod) ::\n  let _cur\n  while true ::\n    let _tip\n    while _cur === (_tip = aod.tip) ::\n      if aod.done :: return\n\n      await aod.tail()\n\n    yield _cur = _tip\n\n\nexport const sym_ao_latest = Symbol('ao_latest')\nconst __ao_latest__ = @{}\n  get [sym_ao_latest]() :: return this\n  xform: _ident\n  get [sym_ao]() ::\n    return _ao_iter_latest.bind(null, this)\n\n  ao_iter() ::\n    return _ao_iter_latest(this)\n\n  async ao_each(fn) ::\n    for await const tip of this ::\n      await fn(tip)\n\n  async * ao_map(fn) ::\n    for await const tip of this ::\n      yield await fn(tip)\n\n  async * ao_filter(fn) ::\n    for await const tip of this ::\n      if await fn(tip) ::\n        yield tip\n\n  async * ao_map_if(fn) ::\n    for await const tip of this ::\n      const res = await fn(tip)\n      if res :: yield res\n\n\nexport function ao_latest() ::\n  const [tail, resume] = ao_fence()\n  const [_fin, _do_stop] = deferred()\n\n  const aod = @{}\n    __proto__: __ao_latest__\n    tip: undefined, done: false,\n    stop, tail\n\n  Object.assign @ update, @{}\n    update, stop, \n    fin: fn => _fin.finally @ _as_fin(fn)\n\n  return @[] aod, update\n\n  function update(tip) ::\n    aod.tip = tip = aod.xform @ tip\n    resume @ tip\n\n  function stop(v) ::\n    aod.done = true\n    resume()\n    _do_stop(v)\n    return _fin\n\n\nfunction _as_fin(fn) ::\n  if 'function' === typeof fn.return ::\n    return v => fn.return(v)\n  return fn\n\n","import {as_ao_iter_checked} from './core_iters.jsy'\nimport {ao_latest} from './core_latest.jsy'\n\nexport function ao_update_ctx(ao_ctx_mgr) ::\n  const [aod, ao_update] = ao_latest()\n\n  ao_ctx_mgr = as_ao_iter_checked @\n    ao_ctx_mgr(ao_update)\n\n  ao_update.fin @ ao_ctx_mgr\n  aod.ready = _ao_init @ ao_ctx_mgr, aod\n  return aod\n\nasync function _ao_init(ao_ctx_mgr, aod) ::\n  const {value: xform} = await ao_ctx_mgr.next()\n  if 'function' === typeof xform ::\n    aod.xform = xform\n  return true\n\n","import {as_ao_iter_checked} from './core_iters.jsy'\nimport {ao_latest} from './core_latest.jsy'\n\nexport function ao_watch(ao_iter) ::\n  ao_iter = as_ao_iter_checked(ao_iter)\n\n  const [aod, ao_update] = ao_latest()\n  ao_update.fin @ ao_iter\n  aod.complete = _ao_walk @ ao_iter, ao_update\n  return aod\n\nasync function _ao_walk(ao_iter, fn) ::\n  for await const v of ao_iter ::\n    await fn(v)\n\n","import {_e_tip} from './_common.jsy'\nimport {sym_ao} from './core_iters.jsy'\nimport {sym_ao_latest} from './core_latest.jsy'\nimport {ao_watch} from './core_watch.jsy'\n\n\nexport async function as_ao_dep(arg) ::\n  if undefined !== arg && null !== arg || 'object' !== typeof arg ::\n\n    const aod = arg[sym_ao_latest]\n    if undefined !== aod ::\n      return aod\n\n    if arg[sym_ao] ::\n      return ao_watch(arg)\n\n    if 'object' === typeof arg && 'tip' in arg ::\n      return arg\n\n  return { tip: arg }\n\nexport async function ao_deps_map(by_entries) ::\n  const aow_deps = new Map()\n  for const [name, arg] of by_entries ::\n    aow_deps.set @ name, await as_ao_dep @ arg\n  return aow_deps\n\n\nexport async function ao_deps_vec(by_vec) ::\n  const aow_deps = []\n  for const arg of by_vec ::\n    aow_deps.push @ await as_ao_dep @ arg\n  return aow_deps\n\n\nexport async function _ao_deps_change(iter_deps) ::\n  await new Promise @\\ resolve ::\n    for const {tail} of iter_deps ::\n      if undefined !== tail ::\n        tail().then(resolve)\n\nexport async function _ao_deps_map_updates(ao_update, deps) ::\n  deps = await ao_deps_map(deps)\n  while true ::\n    ::\n      const snap = {}\n      for const [k, arg] of deps.entries() ::\n        snap[k] = arg.tip\n\n      ao_update @ snap\n\n    await _ao_deps_change @ deps.values()\n\nexport async function _ao_deps_vec_updates(ao_update, deps) ::\n  deps = await ao_deps_vec(deps)\n  while true ::\n    ::\n      const snap = Array.from @ deps, _e_tip\n\n      ao_update @ snap\n\n    await _ao_deps_change @ deps\n\n","import {ao_latest} from './core_latest.jsy'\nimport {_ao_deps_map_updates, _ao_deps_vec_updates} from './track_deps.jsy'\n\nexport function ao_track(deps) ::\n  const [aod, ao_update] = ao_latest()\n  aod.complete = Array.isArray(deps) \n    ? _ao_deps_vec_updates @ ao_update, deps\n    : _ao_deps_map_updates @ ao_update, Object.entries(deps)\n  return aod\n\nexport function ao_track_vec(deps) ::\n  const [aod, ao_update] = ao_latest()\n  aod.complete = _ao_deps_vec_updates @ ao_update, deps\n  return aod\n\nexport function ao_track_entries(deps) ::\n  const [aod, ao_update] = ao_latest()\n  aod.complete = _ao_deps_map_updates @ ao_update, deps\n  return aod\n\nexport function ao_track_kw(deps) ::\n  deps = Object.entries(deps)\n  const [aod, ao_update] = ao_latest()\n  aod.complete = _ao_deps_map_updates @ ao_update, deps\n  return aod\n\n","import {_e_value} from './_common.jsy'\nimport {ao_update_ctx} from './core_updates.jsy'\n\n\nconst _en_click = ['click']\nconst _en_input = ['input', 'change']\nconst _e_no_default = e => e.preventDefault()\nconst _opt_unpack = ({text, value}) => @: text, value\nexport const _dom_std_args = @{}\n  _: @[] _en_click\n  'input': @[] _en_input, _e_value\n  'output': @[] _en_input, _e_value\n  'input,number': @[] _en_input, e => e.valueAsNumber\n  'input,range': @[] _en_input, e => e.valueAsNumber\n  'input,button': @[] _en_click, _e_value\n  'input,submit': @[] _en_click, _e_value\n  'input,checkbox': @[] _en_input, e => e.checked\n  'input,radio': @[] _en_input, e => e.checked\n  'input,date': @[] _en_input, e => e.valueAsDate\n  'input,time': @[] _en_input, e => e.valueAsNumber\n  'input,file': @[] _en_input, e => e.multiple ? e.files : e.files[0]\n  'textarea': @[] _en_input, _e_value\n  'select': @{}\n      evt_names: _en_input\n      on_evt(e) ::\n        const res = Array.from @ e.selectedOptions, _opt_unpack\n        return e.multiple ? res : res[0]\n\n  'form': @{}\n      evt_names: _en_input\n      on_evt: e => new FormData(e)\n      on_add(e) :: e.addEventListener @ 'submit', _e_no_default\n\n\nexport function _dom_builtin(std, elem) ::\n  let {tagName: tag, type} = elem\n  tag = tag.toLowerCase()\n\n  const res =\n    type && std[`${tag},${type.toLowerCase()}`]\n    || std[tag] || std._\n\n  return Array.isArray(res)\n    ? @{} elem, evt_names: res[0], on_evt: res[1]\n    : @{} elem, ... res\n\n\nexport function _dom_unpack_args(std, elem, args) ::\n  if 'string' === typeof elem ::\n    elem = document.querySelector(elem)\n\n  return args && args.length\n    ? @{} elem, evt_names: args[0], on_evt: args[1]\n    : _dom_builtin(std, elem)\n\n\n\nexport const _dom_std_unpack_args = \n  _dom_unpack_args.bind @ null, _dom_std_args\n\nexport function ao_dom(elem, ...args) ::\n  return _ao_dom_updates @\n    _dom_std_unpack_args(elem, args)\n\n\nexport function _ao_dom_updates({elem, evt_names, on_evt, on_calc, on_add, on_remove}) ::\n  if !Array.isArray(evt_names) ::\n    evt_names = (evt_names || 'click').split(/\\s+/)\n\n  const extra = on_evt || {}\n  if 'function' !== typeof on_evt ::\n    on_evt = extra.on_evt\n\n  return ao_update_ctx @\\ ao_update ::*\n    const _update = on_evt\n      ? evt => ao_update @ on_evt(elem, evt)\n      : ()=> ao_update @ elem\n\n    if extra.on_add ::\n      extra.on_add(elem)\n\n    for const e of evt_names ::\n      elem.addEventListener @ e, _update\n\n    try ::\n      _update(elem)\n      yield extra.on_calc\n\n    finally ::\n      for const e of evt_names ::\n        elem.removeEventListener @ e, _update\n\n      if extra.on_remove ::\n        extra.on_remove(elem)\n\n\nexport function ao_animation_frames() ::\n  return ao_update_ctx @\\ ao_update ::*\n    function _update(ts) ::\n      ao_update(ts)\n      rid = requestAnimationFrame @ _update\n\n    let rid = requestAnimationFrame @ _update\n    try :: yield\n    finally :: cancelAnimationFrame(rid)\n\n","import {ao_update_ctx} from './core_updates.jsy'\n\nexport const delay = (...args) =>\n  new Promise @ y =>\n    setTimeout @ y, ...args\n\nexport function ao_pulse(ms, immediate) ::\n  return ao_update_ctx @\\ ao_update ::*\n    const ts0 = Date.now()\n    function _pulse() ::\n      ao_update @ Date.now() - ts0\n\n    const tid = setInterval @ _pulse, ms\n    try ::\n      if immediate :: _pulse()\n\n      yield\n\n    finally ::\n      clearInterval @ tid\n\n"],"names":[],"mappings":";;;;EAIE;;;EAGA;IACE,UAAU;;;MAGT;IACD,oBAAqB;;EAEvB;;;;;;;;ECAA;EACA;IACE;IACA;;;ECdF;EACA;;EAEA;IACE;IACA;;EAEF;IACE;MACE,kBAAmB;;EAEvB;;;ECRA;MACE;IACA;;EAEF;EACA;EACA;;;;EAIA;SACK;IACH;WACK;UACD,WAAY;;MAEd;;IAEF;;;6BAGgC,WAAW;AAC/C;EACE,uBAAwB;EACxB;EACA;IACE;;EAEF;IACE;;EAEF;eACW;MACP;;EAEJ;eACW;MACP;;EAEJ;eACW;UACL;QACA;;EAEN;eACW;MACP;UACE,MAAO;;;;EAIb;EACA;;EAEA;IACE;IACA;IACA;;EAEF,cAAe;IACb;IACA,wBAAyB;;EAE3B,QAAU;;EAEV;IACE,0BAA2B;IAC3B,OAAQ;;EAEV;IACE;IACA;IACA;IACA;;;AAGJ;MACK,UAAU;IACX;EACF;;;ECjFA;;EAEA;IACE;;EAEF,cAAe;EACf,qBAAsB;EACtB;;AAEF;EACE;MACG,UAAU;IACX;EACF;;;ECbA;;EAEA;EACA,cAAe;EACf,wBAAyB;EACzB;;AAEF;aACW;IACP;;;MCNA,qCAAsC,QAAQ;;IAE9C;QACE;MACA;;QAEA;MACA;;QAEC,QAAQ,mBAAmB,KAAK;MACjC;;EAEJ;;;EAGA;OACG;IACD,aAAc,sBAAwB;EACxC;;;;EAIA;OACG;IACD,cAAe,gBAAkB;EACnC;;;;EAIA;SACK;UACC;QACA;;;EAGN;SACK;;MAED;WACG;QACD;;MAEF,UAAW;;IAEb,sBAAuB;;;EAGzB;SACK;;MAED,wBAAyB;;MAEzB,UAAW;;IAEb,sBAAuB;;;ECzDzB;EACA;2BAC0B;2BACA;EAC1B;;;EAGA;EACA,oCAAqC;EACrC;;;EAGA;EACA,oCAAqC;EACrC;;;EAGA;EACA;EACA,oCAAqC;EACrC;;ACpBF,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO,EAAE,QAAQ;AACpC;AACA,wCAAyC;;EAEvC,GAAM;EACN,OAAO,EAAK;EACZ,QAAQ,EAAK;EACb,cAAc,EAAK;EACnB,aAAa,EAAK;EAClB,cAAc,EAAK;EACnB,cAAc,EAAK;EACnB,gBAAgB,EAAK;EACrB,aAAa,EAAK;EAClB,YAAY,EAAK;EACjB,YAAY,EAAK;EACjB,YAAY,EAAK;EACjB,UAAU,EAAK;EACf,QAAQ;MACJ;MACA;QACE,uBAAwB;QACxB;;EAEN,MAAM;MACF;MACA;MACA,WAAY,mBAAqB,QAAS;;;;EAI9C;EACA;;EAEA;IACE,YAAY,GAAG,IAAI,GAAG,mBAAmB,CAAC;;;EAG5C;MACO;MACA;;;;MAIJ,QAAQ;IACT;;EAEF;MACO;;;;;;EAMP,sBAAuB;;;EAGvB;IACE;;;;MAIC;IACD,0BAA0B,OAAO,QAAQ,KAAK;;EAEhD;MACG,UAAU;IACX;;EAEF;IACE;yBACsB;uBACF;;QAElB;MACA;;SAEC;MACD,sBAAuB;;IAEzB;MACE;MACA;;;WAGG;QACD,yBAA0B;;UAE1B;QACA;;;;EAIN;IACE;MACE;MACA,4BAA6B;;IAE/B,gCAAiC;IACjC,KAAM;aACI;;;ECrGZ,YAAa;IACX,WAAY;;;EAGd;IACE;IACA;MACE,UAAW;;IAEb,wBAAyB;IACzB;UACI,YAAa;;MAEf;;;MAGA,cAAe;;;;"}