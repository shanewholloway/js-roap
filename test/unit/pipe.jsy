import {ao_fence_in, ao_drive, ao_run} from 'roap'

import @{}
  assert, expect,
  delay_race, delay, delay_walk,
  array_from_ao_iter,
  is_fn, is_gen, is_async_iterable
from './_utils.jsy'


describe @ 'ao_fence_in.ao_pipe advanced', function() ::
  describe @ 'compute', @::
    it @ 'xfold', @::>
      let some_pipe = ao_fence_in().ao_pipe @:
        *xrecv(g) ::
          for let v of g ::
            yield v + 1000

      let z = array_from_ao_iter(some_pipe)

      await ao_drive @
        delay_walk @# 30,20,10
        some_pipe.g_in, true

      assert.deepEqual @ await z, @[] 1030, 1020, 1010


    it @ '*xgfold', @::>
      let some_pipe = ao_fence_in().ao_pipe @:
        *xrecv(g) ::
          let s = 0
          for let v of g ::
            s += v + 1000
            yield s

      let z = array_from_ao_iter(some_pipe)

      await ao_drive @
        delay_walk @# 30,20,10
        some_pipe.g_in, true

      assert.deepEqual @ await z, @[] 1030, 2050, 3060


    it @ 'xctx', @::>
      let log=[]

      let some_pipe = ao_fence_in().ao_pipe @:
        *xinit(g_in) ::
          log.push @ 'xctx start'
          let tid = setTimeout @ 
            v => g_in.next(v)
            1, 'bingo'

          try ::
            yield * g_in.aog_iter()
          finally ::
            clearTimeout(tid)
            log.push @ 'xctx fin'

      let z = array_from_ao_iter(some_pipe)

      assert.deepEqual @ log, @[] 'xctx start'

      await delay(5)
      some_pipe.g_in.return()

      assert.deepEqual @ log, @[] 'xctx start', 'xctx fin'

      assert.deepEqual @ await z, @[] 'bingo'


  describe @ 'output async generator', @::
    it @ 'raw', @::>
      let gs = is_gen @
        ao_fence_in().ao_xform_raw()

      let v0 = gs.next()
      expect(v0).to.be.a('promise')

      let pd = ao_drive @
        delay_walk @# 30,20,10
        gs.g_in, true

      let pr = ao_run(gs)
      expect(pr).to.be.a('promise')
      expect(await pr).to.be.undefined
      expect(await pd).to.be.undefined

      let v1 = gs.next()
      expect(v1).to.be.a('promise')

      expect(await v0).to.deep.equal @: value: 30, done: false
      expect(await v1).to.deep.equal @: value: undefined, done: true


    it @ 'tap', @::>
      let [f_tap, ag_tap] = ao_fence_in().ao_xform_tap()

      is_async_iterable(f_tap)
      is_gen(ag_tap)
      is_gen(f_tap.g_in)
      is_gen(ag_tap.g_in)
      assert @ f_tap.g_in === ag_tap.g_in, "has same g_in"

      let a = array_from_ao_iter(f_tap.ao_fork())
      let b = array_from_ao_iter(f_tap.ao_fork())

      let z = array_from_ao_iter(f_tap)
      expect(f_tap.fence).to.be.a('function')

      ao_drive @
        delay_walk @# 30,20,10
        f_tap.g_in, true

      expect(a).to.be.a('promise')
      expect(b).to.be.a('promise')
      expect(z).to.be.a('promise')

      await ao_run(ag_tap)

      expect(await z).to.deep.equal @# 30, 20, 10
      expect(await a).to.deep.equal @# 30, 20, 10
      expect(await b).to.deep.equal @# 30, 20, 10


    it @ 'split', @::>
      let gs = is_async_iterable @
        ao_fence_in().ao_xform_run()

      let a = array_from_ao_iter(gs)
      let b = array_from_ao_iter(gs.ao_fork())
      let z = array_from_ao_iter(gs)

      expect(gs.fence).to.be.a('function')
      expect(gs.when_run).to.be.a('promise')

      expect(a).to.be.a('promise')
      expect(b).to.be.a('promise')
      expect(z).to.be.a('promise')

      ao_drive @
        delay_walk @# 30,20,10
        gs.g_in, true

      let p = gs.fence()
      expect(p).to.be.a('promise')
      expect(await p).to.equal @ 30

      expect(await z).to.deep.equal @# 30, 20, 10
      expect(await a).to.deep.equal @# 30, 20, 10
      expect(await b).to.deep.equal @# 30, 20, 10

