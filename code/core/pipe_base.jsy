import {_obj_assign, _is_fn} from './_common.jsy'
import {_xinvoke} from './util.jsy'


export const _ao_pipe_src_base = @{}
  as_pipe_src() :: return this
  // on_fin(gen)

export const _ao_pipe_out_base = @{}
  as_pipe_out() :: return this
  // gsrc
  // on_fin(gen)
  // stop()


//~~~
// Pipe base as generator in composed object-functional implementation

export const _ao_pipe_base = @{}
  xfold: v => v // on push: identity transform
  xpull() {} // memory: none
  xemit: _xinvoke // identity transform or invoke if function
  xinit(gsrc, ag_out) {} // on init: default behavior

  api_src: _ao_pipe_src_base
  api_out: _ao_pipe_out_base


  get create() ::
    // as getter to bind class as `this` at access time
    const create = (... args) =>
      _obj_assign @ {__proto__: this},
        ... args.map(_xinvoke)
      ._ao_pipe()

    return create.create = create

  _ao_pipe() ::
    let fin_lst = []
    let on_fin = g => @ fin_lst.push(g), g
    let stop = @::
      this.done = true
      _fin_pipe(fin_lst)
      this._resume()

    let gsrc =
      _obj_assign @
        on_fin @ this._ao_producer(stop)
        @{} on_fin
        this.api_src
      .as_pipe_src()

    let ag_out =
      _obj_assign @
        on_fin @ this._ao_consumer(stop)
        @{} gsrc, on_fin, stop
        this.api_out
      .as_pipe_out()

    this.xinit(gsrc, ag_out)

    // allow gsrc to initialize
    gsrc.next()
    return ag_out


  //~~~
  // Upstream input generator
  //   designed for multiple feeders

  *_ao_producer(_finish) ::
    try ::
      let v
      while ! this.done ::
        v = this.xfold(yield v)
        this.value = v
        if 0 !== this._waiting && undefined !== v ::
          this._resume()

    finally ::
      _finish()


  //~~~
  // Downstream async output generator
  //   designed for single consumer.

  async *_ao_consumer(_finish) ::
    try ::
      let r
      while ! this.done ::
        if 0 !== (r = this._waiting) ::
          // p0: existing waiters
          r = await r
          if this.done :: break
        else if undefined !== (r = this.value) ::
          // p1: available value
          this.value = undefined
        else if undefined !== (r = this.xpull()) ::
          // p2: xpull value (e.g. queue memory) 
        else ::
          // p3: add new waiter
          r = await this._bind_waiting()
          if this.done :: break

        yield this.xemit(r)

    finally ::
      _finish()


  //~~~
  // generator-like value/done states

  value: undefined
  done: false

  //~~~
  // promise-based fence tailored for ao_pipe usecase

  _waiting: 0
  _fulfill() ::
  async _resume() ::
    if ! this.done :: await this

    let {value, _fulfill} = this
    if undefined != value || this.done ::
      this.value = undefined
      this._waiting = 0
      _fulfill(value)

  _bind_waiting() ::
    let _reset = y => this._fulfill = y
    this._bind_waiting = () => this._waiting || @
      this._waiting = new Promise(_reset)
    return this._bind_waiting()


function _fin_pipe(fin_lst) ::
  while 0 !== fin_lst.length ::
    let g = fin_lst.pop()
    try ::
      if _is_fn(g) :: g()
      else g.return()
    catch (err) ::
      if err instanceof TypeError ::
        if 'Generator is already running' === err.message ::
          continue
      console.error(err)

