import { sym_ao } from './core.jsy'


export const deferred = @!
  const l=[], lset = l.splice.bind(l, 0, 2)
  return function deferred(host) ::
    'use strict';
    if undefined === host ::
      host = this || {reset: deferred}

    host.promise = new Promise(lset)
    host.resolve = l[0]
    host.reject = l[1]
    return host


const __ao_deferred__ = @{}
  tip: undefined
  valid: false
  done: false
  reset: deferred

  get [sym_ao]() ::
    return ao_iter_deferred.bind(null, this)


export async function * ao_iter_deferred(aod, only_next) ::
  if !only_next && aod.valid ::
    yield aod.tip

  while true ::
    await aod.promise
    if false !== aod.done ::
      return await aod.done
    yield aod.tip


export function ao_deferred(...args) ::
  const ao_kind = 'string' === typeof args[0] ? args.shift() : 'ao_update'
  const init_ao = args.pop()

  const aod = deferred @: __proto__: __ao_deferred__
  const ao_api = _ao_deferred_api[ao_kind] @ aod

  if undefined !== init_ao ::
    aod.init = init_ao(ao_api)
  else aod[ao_kind] = ao_api

  return aod


const _ao_deferred_api = @{}
  ao_update: aod => @
    function ao_update(v) ::
      aod.valid = true
      aod.tip = v
      aod.resolve(v)
      return aod.promise

  ao_gen: aod => @:
    update(v) ::
      aod.valid = true
      aod.tip = v
      aod.resolve(v)
      return aod.promise

    return(v) ::
      aod.done = Promise.resolve(v)
      aod.resolve()
      return aod.done

    throw(err) ::
      aod.done = Promise.reject(err)
      aod.resolve()
      return aod.done

