import {as_ao_watch, _ao_watcher} from './watch_core.jsy'


export @{}
  ao_watch_compute_kw as default,
  ao_watch_compute_kw as ao_watch_compute,
  ao_compute_kw as ao_compute,


export function _ao_wrap_watcher(_ao_compute_with) ::
  return fn_compute =>
    _ao_watcher @ {}, _ao_compute_with(fn_compute)

export function ao_watch_compute_args(...args) ::
  return _ao_wrap_watcher @
    ao_compute_pos @ args

export function ao_watch_compute_pos(by_pos) ::
  return _ao_wrap_watcher @
    ao_compute_pos @ by_pos

export function ao_watch_compute_kw(by_kw) ::
  return _ao_wrap_watcher @
    ao_compute_entries @ Object.entries(by_kw)

export function ao_watch_compute_entries(by_entries) ::
  return _ao_wrap_watcher @
    ao_compute_entries @ by_entries



export function ao_compute_args(...args) ::
  return _ao_compute_with.bind @ null,
    _ao_watch_deps_set(args)
    _ao_compute_pos

export function ao_compute_pos(by_pos) ::
  return _ao_compute_with.bind @ null,
    _ao_watch_deps_set(by_pos)
    _ao_compute_pos

export function ao_compute_kw(by_kw) ::
  return _ao_compute_with.bind @ null,
    _ao_watch_deps_map(Object.entries(by_kw))
    _ao_compute_kw

export function ao_compute_entries(by_entries) ::
  return _ao_compute_with.bind @ null,
    _ao_watch_deps_map(by_entries)
    _ao_compute_kw



export async function _ao_watch_deps_set(by_pos) ::
  const watch_deps = new Set()
  for const each of by_pos ::
    watch_deps.add @ await as_ao_watch @ each
  return watch_deps

export async function _ao_watch_deps_map(by_entries) ::
  const watch_deps = new Map()
  for const [name, each] of by_entries ::
    watch_deps.set @ name, await as_ao_watch @ each
  return watch_deps


export async function _ao_watch_join(watch_deps) ::
  await new Promise @\ resolve ::
    for const {tail} of watch_deps.values() ::
      if undefined !== tail ::
        tail.then(resolve)

export async function * _ao_compute_with(watch_deps, _ao_compute, fn_compute, only_next) ::
  watch_deps = await watch_deps
  if only_next ::
    await _ao_watch_join @ watch_deps

  while true ::
    yield _ao_compute @ watch_deps, fn_compute
    await _ao_watch_join @ watch_deps

const _obj_value = o => o.value
export function _ao_compute_pos(watch_deps, fn_compute) ::
  const deps = Array.from @ watch_deps.values(), _obj_value
  return fn_compute(... deps)

export function _ao_compute_kw(watch_deps, fn_compute) ::
  const deps = {}
  for const [k,d] of watch_deps.entries() ::
    deps[k] = d.value
  return fn_compute(deps)

