const sym_ao = Symbol.asyncIterator

async function * aod_iterator(aod) ::
  let _cur
  while true ::
    let _tip
    while _cur === (_tip = aod.tip) ::
      if aod.done ::
        return

      await aod.block()

    yield _cur = _tip

function ao_fence() ::
  let _next, _resume=@=>null
  const _set = y => _resume = y

  resume.block = @=>
    undefined !== _next ? _next :
      _next = new Promise @ _set

  return resume

  function resume(v) ::
    _next = undefined
    _resume(v)


function ao_bingo() ::
  const aod = @{}
    done: false, valid: false
    tip: undefined
    block: ao_block()
    [sym_ao]() :: return aod_iterator(aod)
    ao_iter() :: return aod_iterator(aod)
    ao_update

  return aod

  function ao_update(v) ::
    aod.valid = true
    aod.tip = v
    aod.block.resume(v)



::!>
  Object.assign @ window, @{}
    ao_block, ao_bingo

  const g = window.g = ao_bingo()
  window.n = 100

  g.ao_update(23)
  g.ao_update(1923)

  for await const e of g ::
    console.log @: e, n: ++window.n
